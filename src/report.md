## Part 1. Настройка gitlab-runner


Выполняю установку и запуск Gitlab Runner по инструкции с ``` https://docs.gitlab.com/runner/install/linux-manually/ ```

1. Поднимаю машину Ubuntu Server 22.04 LTS и устанавливаю Gitlab Runner командой ``` curl -L --output /usr/local/bin/gitlab-runner "https://s3.dualstack.us-east-1.amazonaws.com/gitlab-runner-downloads/latest/binaries/gitlab-runner-linux-amd64" ```

![a](img/1.1.jpg)

2. Делаю gitlab runner исполняемым

![a](img/1.2.jpg)

3. Создаю пользователя

![a](img/1.3.jpg)

4. Устанавливаю и запускаю службу

![a](img/1.4.jpg)

5. Загружаю вспомогательные образы

![a](img/1.5.jpg)

6. Провожу регистрацию раннера


![a](img/1.6.jpg)


## Part 2. Сборка

1. Скачиваю папки cat и grep из проекта SimpleBashUtils

![a](img/2.1.jpg)

2. В папке DO6_CICD.ID_356283-1 создаю файл ```.gitlab-ci.yml```, в котором прописываю этапы сборки cat и grep с помощью Makefile. В файле одна стадия компиляции двух проектов. Артефакты сохраняются в файлы ```cat_artifacts``` и ```grep_artifacts``` по пути в соответствии с проектами со сроком хранения 30 дней

![a](img/2.2.jpg)

3. Пушу файл в гитлаб и автоматически проводится сборка

![a](img/2.3.jpg)

##### cat:

![a](img/2.4.jpg)

![a](img/2.5.jpg)

##### grep: 

![a](img/2.6.jpg)

![a](img/2.7.jpg)


## Part 3. Тест кодстайла

1. Создаю скрипт, который будет сохранять вывод clang-format в файл ```clang_output.txt``` и проверять, пустой он или нет. Если пустой, то значит тест на стиль прошел успешно, если не пустой - тест зафейлен и пайплайн тоже будет зафейлен

![a](img/3.1.jpg)

2. Копирую скрипт в каждую папку

![a](img/3.2.jpg)

3. Добавляю тест на стиль в ```.gitlab-ci.yml```

![a](img/3.3.jpg)

4. Проверка проходит успешно

![a](img/3.4.jpg)

![a](img/3.5.jpg)

5. Специально делаю ошибку в стиле в файле s21_cat.c, чтобы проверить реакцию скрипта. В этом случае пайплайн фейлится

![a](img/3.6.jpg)

![a](img/3.7.jpg)

6. Немного изменила ```.gitlab-ci.yml```, чтобы скрипт проверки стиля копировался в папки cat и grep и не приходилось каждый раз перемещать его вручную при изменениях

![a](img/3.8.jpg)

7. Также в скрипте проверки стиля сделала так, чтобы в случае ошибки выходило ее содержание

![a](img/3.9.jpg)

8. Вывод пайплайна:

	##### в случае ошибки: 
    
    ![a](img/3.10.jpg)

	![a](img/3.11.jpg)
    
    ##### без ошибок:
    
    ![a](img/3.12.jpg)

	![a](img/3.13.jpg)
    
    
## Part 4. Интеграционные тесты

1. Пишу скрипт который будет проверять успешность тестов. В скриптах тестов cat и grep выводится количество ошибок в строке "fail - [кол-во]". Если будут ошибки, то команда grep не найдет и не запишет в файлы ```cat_grep_fail.txt``` ```grep_grep_fail.txt``` строку ```fail - 0```, от которой и будет зависеть успешность пайплайна. 

В случае успеха вывод - ```Test success```, ошибка - ```Test fail```

![a](img/4.1.jpg)

2. Добавляю в ```.gitlab-ci.yml``` стадию ```test```, которая запускает наш скрипт в случае, если прошлые стадии успешны

![a](img/4.2.jpg)

![a](img/4.3.jpg)

3. Стадия проходит успешно

![a](img/4.4.jpg)

![a](img/4.5.jpg)

4. Теперь делаю ошибку стиля в cat и проверяю работу стадии. Она скипается

![a](img/4.6.jpg)

5. При неуспешности тестов пайплайн фейлится

![a](img/4.7.jpg)

![a](img/4.8.jpg)

## Part 5. Этап деплоя

1. Запускаю вторую машину и добавляю новый адаптер на обеих машинах, чтобы объединить их в сеть. Добавляю статический айпи в нетплане

##### машина 1

![a](img/5.2.jpg)

##### машина 2

![a](img/5.3.jpg)

2. Проверяю айпи на машинах

![a](img/5.4.jpg)

3. Меняю пользователя на gitlab-runner и создаю новый ssh ключ на машине. Копирую публичный ключ и добавляю в Gitlab. То же самое делаю с машиной 2

![a](img/5.5.jpg)

![a](img/5.6.jpg)

![a](img/5.6a.jpg)

4. Добавяю ключ в папку ```~/.ssh/authorized_keys``` на машине 2

![a](img/5.7.jpg)

5. Подкючаюсь с машины 1 к машине 2 по ssh через айпи в локальной сети. Благодаря добавлению публичного ключа на машину 2, пароль от УЗ не требуется. Выхожу через exit

![a](img/5.8.jpg)

6. Добавляю айпи машины 2 в ```known_hosts``` на машине 1


![a](img/5.9.jpg)

7. Создаю скрипт ```deploy.sh```, который будет копировать нужные файлы на машину 2

![a](img/5.10.jpg)

8. Добавляю деплой в ```.gitlab-ci.yml```, он будет запускаться вручную

![a](img/5.11.jpg)

![a](img/5.12.jpg)

9. Выгружаю в гитлаб и запускаю деплой

![a](img/5.13.jpg)

![a](img/5.14.jpg)

 ![a](img/5.15.jpg)
